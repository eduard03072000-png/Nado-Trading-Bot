# ⚡ Nado DEX Trading Bot — Как всё работает

## Общая архитектура

Проект состоит из трёх слоёв которые работают вместе:

```
Telegram (ты) → Telegram Bot API → trading_bot → Nado DEX (блокчейн)
                                        ↕
                               Mini App (браузер в TG)
                                        ↕
                               Flask API (сервер)
```

---

## На чём написано

**Язык:** Python 3.12

**Основные библиотеки:**
- `nado-protocol` — официальный SDK для Nado DEX. Через него идут все торговые операции: открытие/закрытие позиций, получение баланса, цен, ордеров
- `python-telegram-bot 22` — асинхронный фреймворк для Telegram бота. Обрабатывает команды, inline-кнопки, callback-запросы
- `Flask` — лёгкий веб-сервер. Отдаёт Mini App и REST API
- `web3` — работа с Ink Network (блокчейн на базе Ethereum)
- `python-dotenv` — загрузка приватных ключей из `.env` файла

**Инфраструктура на сервере:**
- `nginx` — reverse proxy, принимает HTTPS трафик и пробрасывает на Flask
- `Let's Encrypt` — бесплатный SSL сертификат (домен `nado-trade.duckdns.org`)
- `systemd` — два сервиса (`trading-bot` и `trading-webapp`) запускаются автоматически при старте сервера и перезапускаются при падении

---

## Файлы и что они делают

**`telegram_trading_bot.py`** — главный файл бота. Содержит все хендлеры команд и кнопок. Когда нажимаешь LONG — он вызывает `trading_dashboard_v2.py` который отправляет реальный ордер на DEX. Бот запускается через `Application.run_polling()` и висит в бесконечном цикле.

**`trading_dashboard_v2.py`** — ядро торгового движка. Содержит класс `TradingDashboard` который напрямую общается с Nado DEX через `nado-protocol`. Здесь живёт логика: открытие позиций, расчёт размера ордера, нормализация цен (все цены в DEX хранятся как целые числа умноженные на 10^18), автоматические TP/SL ордера.

**`multi_wallet_dashboard.py`** — обёртка над `TradingDashboard` для работы с двумя кошельками одновременно. Хранит два экземпляра дашборда и переключается между ними через `active_wallet`.

**`webapp_server.py`** — Flask сервер с REST API. Запускается на порту 8080. nginx принимает запросы на 443 (HTTPS) и проксирует сюда. Эндпоинты: `/api/balance`, `/api/positions`, `/api/prices`, `/api/trade`, `/api/close`.

**`webapp/index.html`** — весь Mini App в одном HTML файле. Чистый JS без фреймворков. При открытии в Telegram подключает `telegram-web-app.js` который даёт доступ к Telegram теме, haptic feedback и методу `tg.expand()`. Данные получает через `fetch()` к Flask API.

**`config.py`** — загружает переменные из `.env`. Содержит функции `get_nado_key()`, `get_telegram_token()` и т.д. Если переменная не найдена — бросает исключение с понятным сообщением.

**`trade_history_manager.py`** — сохраняет историю сделок в JSON файл. Записывает: символ, сторону, размер, цену входа/выхода, PnL, время.

**`tp_sl_calculator.py`** — калькулятор TP/SL прямо в боте. Считает уровни по процентам с учётом левериджа.

**`historical_data_provider.py`** — получает исторические свечи с DEX для анализа.

---

## Как проходит торговая операция (LONG ETH)

1. Ты нажимаешь **LONG** в боте
2. Бот спрашивает размер позиции
3. Ты вводишь, например, `10` (USDC)
4. `telegram_trading_bot.py` вызывает `dashboard.place_order(product_id=4, size=10, is_long=True)`
5. `trading_dashboard_v2.py` нормализует размер (ETH шаг = 0.01), рассчитывает цену
6. Через `nado-protocol` подписывает EIP-712 транзакцию приватным ключом
7. Отправляет ордер на Nado DEX (Ink Network)
8. DEX исполняет ордер, позиция открыта
9. Бот автоматически выставляет TP и SL ордера если они указаны
10. Тебе приходит подтверждение с деталями сделки

---

## Как работает Mini App

Mini App — это обычная веб-страница которая открывается внутри Telegram. Telegram предоставляет специальный JS SDK (`telegram-web-app.js`) который позволяет ей знать тему оформления, вибрировать при нажатии и закрываться по кнопке.

Страница делает `fetch` запросы к `https://nado-trade.duckdns.org/api/...` — это nginx на сервере который проксирует на Flask. Flask обращается к `MultiWalletDashboard` который идёт в блокчейн и возвращает данные.

Для Telegram Mini App обязательно нужен **HTTPS с валидным сертификатом** — поэтому настроили DuckDNS домен + Let's Encrypt.

---

## Где всё крутится

**Сервер:** VPS `198.13.184.39` (Ubuntu 24)

Два systemd сервиса:
- `trading-bot.service` — запускает `telegram_trading_bot.py`, автоперезапуск при падении
- `trading-webapp.service` — запускает `webapp_server.py` (Flask на порту 8080)

nginx слушает порт 443, проксирует на 8080. Сертификат обновляется автоматически через certbot cron.
